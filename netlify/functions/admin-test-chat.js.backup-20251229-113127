/**
 * Admin Chat Tester Endpoint
 * POST /api/admin-test-chat
 *
 * Allows admins to test the chatbot with full tool calling support (availability + booking)
 */

const { validateAdminSession } = require('./shared/redis-client');

/**
 * Strip markdown formatting from text for plain display
 * @param {string} text - Text potentially containing markdown
 * @returns {string} - Clean text without markdown symbols
 */
function stripMarkdown(text) {
  if (!text) return text;

  return text
    // Remove bold **text** or __text__
    .replace(/\*\*(.+?)\*\*/g, '$1')
    .replace(/__(.+?)__/g, '$1')
    // Remove italic *text* or _text_ (but not single _ in words)
    .replace(/\*([^*\n]+)\*/g, '$1')
    // Remove headers # ## ###
    .replace(/^#{1,6}\s+/gm, '')
    // Remove bullet points - and * at start of lines, keep content
    .replace(/^[\s]*[-*]\s+/gm, '')
    // Remove numbered list formatting but keep numbers
    .replace(/^(\d+)\.\s+/gm, '$1. ')
    // Remove code blocks ```
    .replace(/```[\s\S]*?```/g, '')
    // Remove inline code `text`
    .replace(/`([^`]+)`/g, '$1')
    // Remove blockquotes >
    .replace(/^>\s+/gm, '')
    // Clean up extra whitespace
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

// Calculate dates for system prompt
const today = new Date();
const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);
const nextMonday = new Date(today);
nextMonday.setDate(today.getDate() + daysUntilMonday);

// System prompt with booking capabilities
const SYSTEM_PROMPT = `Eres el asistente virtual de LaserOstop Espa√±a, especialista en tratamientos l√°ser para dejar adicciones.

## IDENTIDAD
- Nombre: Asistente LaserOstop
- Rol: Community Manager / Atenci√≥n al cliente
- Idioma: SOLO espa√±ol de Espa√±a
- Tono: Profesional, cercano y emp√°tico
- Fecha de HOY: ${today.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}
- Pr√≥ximo lunes: ${nextMonday.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}

## INTERPRETACI√ìN DE FECHAS - MUY IMPORTANTE
- "esta semana" = desde hoy (${today.getDate()} dic) hasta el domingo
- "pr√≥xima semana" o "next week" = desde el pr√≥ximo lunes (${nextMonday.getDate()} dic) en adelante
- NUNCA incluir fechas anteriores al pr√≥ximo lunes cuando el usuario pide "pr√≥xima semana"
- Si hoy es ${today.toLocaleDateString('es-ES', { weekday: 'long' })}, la pr√≥xima semana empieza el lunes ${nextMonday.getDate()}

## HERRAMIENTAS DISPONIBLES (OBLIGATORIO USARLAS)

Tienes acceso a estas herramientas que DEBES usar:
1. check_availability - Para consultar horarios disponibles
2. create_booking - Para crear reservas (OBLIGATORIO para confirmar citas)
3. get_center_info - Para informaci√≥n de centros

## REGLA CR√çTICA - DISPONIBILIDAD

- SOLO muestra los horarios EXACTOS que devuelve check_availability
- Si check_availability devuelve slots: [] (vac√≠o), DEBES decir "No hay disponibilidad en este momento"
- NUNCA inventes horarios que no aparecen en la respuesta de la herramienta
- Si no hay slots, recomienda otro centro o contactar por WhatsApp: +34 689 560 130
- Los horarios mostrados DEBEN corresponder exactamente a los de la respuesta de check_availability

## REGLA CR√çTICA - CREAR RESERVAS

NUNCA digas que una reserva est√° confirmada sin haber llamado a create_booking
DEBES llamar a create_booking con TODOS los par√°metros para crear una reserva real
Solo puedes confirmar una reserva cuando create_booking devuelve success: true
SIEMPRE incluye el n√∫mero de reserva (appointmentId) en la confirmaci√≥n
Si create_booking devuelve un error, DEBES informar al usuario del problema

Par√°metros OBLIGATORIOS para create_booking:
- center: c√≥digo del centro (barcelona, sevilla, chamartin, atocha, torrejon, majadahonda)
- treatment: tipo (tabaco, duo, cannabis, azucar)
- date: fecha en formato YYYY-MM-DD
- time: hora en formato HH:MM
- full_name: nombre completo del cliente
- email: correo electr√≥nico
- phone: tel√©fono (m√≠nimo 9 d√≠gitos)

## CENTROS Y C√ìDIGOS
- Barcelona Sants ‚Üí c√≥digo: "barcelona"
- Sevilla ‚Üí c√≥digo: "sevilla"
- Madrid Chamart√≠n ‚Üí c√≥digo: "chamartin"
- Madrid Atocha ‚Üí c√≥digo: "atocha"
- Majadahonda ‚Üí c√≥digo: "majadahonda"
- Torrej√≥n de Ardoz ‚Üí c√≥digo: "torrejon"

## TRATAMIENTOS Y PRECIOS
- tabaco (individual): 190‚Ç¨
- duo (2 personas): 360‚Ç¨ total
- cannabis: 250‚Ç¨
- azucar: 200‚Ç¨

## FLUJO DE RESERVA

1. Usuario pide cita ‚Üí Pregunta centro y tratamiento si no los dice
2. Usa check_availability para obtener horarios REALES
3. Usuario elige horario ‚Üí Recoge nombre, email, tel√©fono
4. Cuando tengas TODOS los datos ‚Üí Muestra resumen y pregunta EXACTAMENTE: "¬øConfirmo la reserva?"
5. Usuario dice s√≠ ‚Üí LLAMA INMEDIATAMENTE a create_booking con todos los par√°metros
6. Si create_booking devuelve success ‚Üí Confirma con el n√∫mero de reserva
7. Si create_booking falla ‚Üí Informa del error y ofrece WhatsApp: +34 689 560 130

## REGLA CR√çTICA DE CONFIRMACI√ìN

NUNCA digas "confirmado", "reservado", "listo" o similar SIN haber llamado a create_booking primero.
Cuando el usuario diga "s√≠", "ok", "confirmo", "adelante" despu√©s de ver el resumen:
- DEBES llamar a create_booking INMEDIATAMENTE en esa misma respuesta
- NO pidas m√°s confirmaciones adicionales
- Si create_booking devuelve success: true, ENTONCES puedes decir que est√° confirmado
- Si no llamaste a create_booking, NO est√° confirmado aunque el usuario haya dicho "s√≠"

## FORMATO DE RESPUESTAS - MUY IMPORTANTE
- NUNCA uses formato markdown (**, *, #, -, etc.)
- Escribe en texto plano sin s√≠mbolos de formato
- Para listas de horarios, muestra cada d√≠a en una NUEVA L√çNEA separada
- M√°ximo 2-3 p√°rrafos cortos
- Un emoji m√°ximo por mensaje
- Ejemplo de formato de horarios:
  üìÖ Disponibilidad:
  Lunes 30 dic: 10:00, 11:00, 12:00
  Martes 31 dic: 10:00, 11:00
- NO uses asteriscos, guiones ni otros s√≠mbolos de formato

Responde de forma natural, como un asesor real de LaserOstop.`;

// Tool definitions
const CHATBOT_TOOLS = [
  {
    type: "function",
    function: {
      name: "check_availability",
      description: "Consultar disponibilidad de citas en un centro LaserOstop.",
      parameters: {
        type: "object",
        properties: {
          center: {
            type: "string",
            enum: ["barcelona", "sevilla", "chamartin", "atocha", "torrejon", "majadahonda"],
            description: "Centro donde consultar disponibilidad"
          },
          treatment: {
            type: "string",
            enum: ["tabaco", "duo", "cannabis", "azucar"],
            description: "Tipo de tratamiento"
          },
          days_ahead: {
            type: "number",
            description: "N√∫mero de d√≠as a consultar"
          }
        },
        required: ["center"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "create_booking",
      description: "OBLIGATORIO: Debes llamar a esta funci√≥n para confirmar cualquier reserva. Sin llamar a esta funci√≥n, la reserva NO se crea. Llama cuando el usuario confirme con 's√≠', 'confirmo', 'ok', 'adelante', etc.",
      parameters: {
        type: "object",
        properties: {
          center: {
            type: "string",
            enum: ["barcelona", "sevilla", "chamartin", "atocha", "torrejon", "majadahonda"],
            description: "C√≥digo del centro: barcelona, sevilla, chamartin, atocha, torrejon, majadahonda"
          },
          treatment: {
            type: "string",
            enum: ["tabaco", "duo", "cannabis", "azucar"],
            description: "Tipo de tratamiento"
          },
          date: { type: "string", description: "Fecha en formato YYYY-MM-DD (ej: 2025-12-23)" },
          time: { type: "string", description: "Hora en formato HH:MM (ej: 15:00)" },
          full_name: { type: "string", description: "Nombre completo del cliente" },
          email: { type: "string", description: "Email del cliente" },
          phone: { type: "string", description: "Tel√©fono del cliente (m√≠nimo 9 d√≠gitos)" }
        },
        required: ["center", "treatment", "date", "time", "full_name", "email", "phone"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "get_center_info",
      description: "Obtener informaci√≥n sobre los centros LaserOstop.",
      parameters: {
        type: "object",
        properties: {
          center: {
            type: "string",
            enum: ["barcelona", "sevilla", "chamartin", "atocha", "torrejon", "majadahonda", "all"]
          }
        },
        required: ["center"]
      }
    }
  }
];

// Center mapping for Smart Agenda API
const CENTERS = {
  'barcelona': { agendaId: '43', name: 'Barcelona Sants', groupId: '4' },
  'sevilla': { agendaId: '44', name: 'Sevilla', groupId: '5' },
  'chamartin': { agendaId: '48', name: 'Madrid Chamart√≠n', groupId: '7' },
  'torrejon': { agendaId: '49', name: 'Torrej√≥n de Ardoz', groupId: '6' },
  'atocha': { agendaId: '50', name: 'Madrid Atocha', groupId: '8' },
  'majadahonda': { agendaId: '51', name: 'Majadahonda', groupId: '10' }
};

const APPOINTMENT_TYPES = {
  '43': { 'tabaco': '20', 'duo': '21', 'cannabis': '23', 'recaida': '22', 'azucar': '91' },
  '44': { 'tabaco': '32', 'duo': '34', 'cannabis': '37', 'recaida': '35', 'azucar': '96' },
  '48': { 'tabaco': '44', 'duo': '46', 'cannabis': '49', 'recaida': '47', 'azucar': '93' },
  '49': { 'tabaco': '53', 'duo': '56', 'cannabis': '59', 'recaida': '57', 'azucar': '97' },
  '50': { 'tabaco': '63', 'duo': '65', 'cannabis': '68', 'recaida': '66', 'azucar': '92' },
  '51': { 'tabaco': '72', 'duo': '74', 'cannabis': '77', 'recaida': '75', 'azucar': '94' }
};

const TREATMENTS = {
  'tabaco': { name: 'Dejar de fumar (individual)', duration: 60, price: 190 },
  'duo': { name: 'Dejar de fumar (d√∫o)', duration: 90, price: 360 },
  'cannabis': { name: 'Adicci√≥n al cannabis', duration: 60, price: 250 },
  'azucar': { name: 'Adicci√≥n al az√∫car', duration: 60, price: 200 }
};

const CENTER_DETAILS = {
  'barcelona': { name: 'LaserOstop Barcelona Sants', address: 'Carrer de Galileu, 65, Sants-Montju√Øc, 08028 Barcelona', phone: '+34 689 560 130' },
  'sevilla': { name: 'LaserOstop Sevilla', address: 'Avenida Eduardo Dato 85, 41005 Sevilla', phone: '+34 689 560 130' },
  'chamartin': { name: 'LaserOstop Madrid Chamart√≠n', address: 'Calle de Oruro, 9, Chamart√≠n, 28016 Madrid', phone: '+34 919 305 313' },
  'atocha': { name: 'LaserOstop Madrid Atocha', address: 'Calle Canarias 26, Atocha, 28045 Madrid', phone: '+34 613 255 948' },
  'torrejon': { name: 'LaserOstop Torrej√≥n de Ardoz', address: 'Calle Pesquera, 10, 28850 Torrej√≥n de Ardoz', phone: '+34 919 305 313' },
  'majadahonda': { name: 'LaserOstop Majadahonda', address: 'Calle del Dr Calero, 19, Centro comercial Tutti, 28220 Majadahonda', phone: '+34 919 305 313' }
};

// Token cache for Smart Agenda
let tokenCache = { token: null, expiry: null };

async function getSmartAgendaToken() {
  if (tokenCache.token && tokenCache.expiry && Date.now() < tokenCache.expiry - 300000) {
    return tokenCache.token;
  }

  const baseUrl = process.env.SMART_AGENDA_BASE_URL || 'https://www.smartagenda.fr/pro/laserostop-esh/api';
  const response = await fetch(`${baseUrl}/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      login: process.env.SMART_AGENDA_LOGIN,
      pwd: process.env.SMART_AGENDA_PWD,
      api_id: process.env.SMART_AGENDA_API_ID,
      api_key: process.env.SMART_AGENDA_API_KEY
    })
  });

  if (!response.ok) throw new Error(`Token request failed: ${response.status}`);
  const data = await response.json();
  tokenCache = { token: data.token, expiry: Date.now() + (2 * 60 * 60 * 1000) };
  return data.token;
}

async function smartAgendaRequest(endpoint, options = {}) {
  const token = await getSmartAgendaToken();
  const baseUrl = process.env.SMART_AGENDA_BASE_URL || 'https://www.smartagenda.fr/pro/laserostop-esh/api';

  console.log(`[ADMIN-TEST-CHAT] Smart Agenda request: ${options.method || 'GET'} ${endpoint}`);

  const response = await fetch(`${baseUrl}${endpoint}`, {
    ...options,
    headers: {
      'X-SMARTAPI-TOKEN': token,
      'Content-Type': 'application/json',
      ...options.headers
    }
  });

  console.log(`[ADMIN-TEST-CHAT] Smart Agenda response: ${response.status}`);

  return response;
}

function formatSpanishDate(dateStr) {
  const date = new Date(dateStr + 'T00:00:00');
  return date.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' });
}

/**
 * Filter slots to show max 3 days with 3 spaced-out times per day
 * Selects morning (9-11), midday (12-14), afternoon (15-18) when possible
 */
function filterOptimalSlots(slots, maxDays = 3, slotsPerDay = 3) {
  // Take first maxDays days that have availability
  const limitedDays = slots.slice(0, maxDays);

  return limitedDays.map(day => {
    const times = day.times;
    if (times.length <= slotsPerDay) return day;

    // Select spaced slots: morning (9-11:30), midday (12-14:30), afternoon (15-19)
    const morning = times.find(t => t >= '09:00' && t <= '11:30');
    const midday = times.find(t => t >= '12:00' && t <= '14:30');
    const afternoon = times.find(t => t >= '15:00' && t <= '19:00');

    const selected = [morning, midday, afternoon].filter(Boolean);

    // If we have 3 spaced slots, use them
    if (selected.length >= slotsPerDay) {
      return { ...day, times: selected.slice(0, slotsPerDay), timesFormatted: selected.slice(0, slotsPerDay).join(', ') };
    }

    // Otherwise, distribute evenly across available times
    const step = Math.max(1, Math.floor(times.length / slotsPerDay));
    const distributed = [];
    for (let i = 0; i < slotsPerDay && i * step < times.length; i++) {
      distributed.push(times[i * step]);
    }
    return { ...day, times: distributed, timesFormatted: distributed.join(', ') };
  });
}

async function executeToolCall(toolName, args) {
  console.log(`[ADMIN-TEST-CHAT] Executing tool: ${toolName}`, args);

  switch (toolName) {
    case 'check_availability': {
      const center = CENTERS[args.center?.toLowerCase()];
      if (!center) {
        return { success: false, error: 'invalid_center', message: `Centro no v√°lido: ${args.center}` };
      }

      const treatment = args.treatment || 'tabaco';
      const typeId = APPOINTMENT_TYPES[center.agendaId]?.[treatment];
      if (!typeId) {
        return { success: false, error: 'invalid_treatment', message: `Tratamiento no v√°lido: ${treatment}` };
      }

      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + (args.days_ahead || 14));

      try {
        const requestBody = {
          pdo_type_rdv_id: typeId,
          pdo_agenda_id: center.agendaId,
          date_a_partir_de: startDate.toISOString().split('T')[0],
          date_fin: endDate.toISOString().split('T')[0]
        };
        console.log('[ADMIN-TEST-CHAT] Availability request:', JSON.stringify(requestBody));

        const response = await smartAgendaRequest('/service/getAvailabilities', {
          method: 'POST',
          body: JSON.stringify(requestBody)
        });

        console.log('[ADMIN-TEST-CHAT] Availability response status:', response.status);

        if (response.status === 404) {
          console.log('[ADMIN-TEST-CHAT] NO SLOTS AVAILABLE - 404 response');
          return { success: true, center: center.name, treatment: TREATMENTS[treatment]?.name, slots: [], message: `No hay disponibilidad en ${center.name} en los pr√≥ximos d√≠as.` };
        }

        const rawData = await response.text();
        console.log('[ADMIN-TEST-CHAT] Availability raw response:', rawData.substring(0, 500));

        let data;
        try {
          data = JSON.parse(rawData);
        } catch (e) {
          console.error('[ADMIN-TEST-CHAT] Failed to parse availability response:', e.message);
          return { success: true, center: center.name, treatment: TREATMENTS[treatment]?.name, slots: [], message: `Error al consultar disponibilidad en ${center.name}.` };
        }
        const dayNames = { 'Monday': 'Lunes', 'Tuesday': 'Martes', 'Wednesday': 'Mi√©rcoles', 'Thursday': 'Jueves', 'Friday': 'Viernes', 'Saturday': 'S√°bado', 'Sunday': 'Domingo' };
        const slots = [];

        for (const day of (data || [])) {
          const times = day.det?.map(slot => slot.idp) || [];
          if (times.length > 0) {
            slots.push({
              dayName: dayNames[day.nj] || day.nj,
              date: day.dj,
              displayDate: formatSpanishDate(day.dj),
              times,
              timesFormatted: times.join(', ')
            });
          }
        }

        console.log(`[ADMIN-TEST-CHAT] Availability result: ${slots.length} days with slots found (before filtering)`);

        // Apply optimal slot filtering: max 3 days, 3 spaced slots per day
        const filteredSlots = filterOptimalSlots(slots);

        if (filteredSlots.length === 0) {
          console.log('[ADMIN-TEST-CHAT] NO SLOTS AVAILABLE - empty result');
        } else {
          console.log(`[ADMIN-TEST-CHAT] Filtered to ${filteredSlots.length} days:`);
          filteredSlots.forEach(s => console.log(`[ADMIN-TEST-CHAT]   ${s.date}: ${s.times.join(', ')}`));
        }

        return {
          success: true,
          center: center.name,
          treatment: TREATMENTS[treatment]?.name || treatment,
          price: TREATMENTS[treatment]?.price || 0,
          slots: filteredSlots,
          message: filteredSlots.length === 0 ? `No hay disponibilidad en ${center.name} actualmente. Te recomendamos consultar otro centro o contactar por WhatsApp: +34 689 560 130` : null
        };
      } catch (error) {
        console.error('[ADMIN-TEST-CHAT] Availability error:', error.message);
        return { success: false, error: 'api_error', message: 'Error al consultar disponibilidad.' };
      }
    }

    case 'create_booking': {
      const { center, treatment, date, time, full_name, email, phone } = args;

      if (!center || !treatment || !date || !time || !full_name || !email || !phone) {
        return { success: false, error: 'missing_fields', message: 'Faltan datos para la reserva.' };
      }

      if (!email.includes('@')) {
        return { success: false, error: 'invalid_email', message: 'El email no es v√°lido.' };
      }

      const phoneDigits = phone.replace(/\D/g, '');
      if (phoneDigits.length < 9) {
        return { success: false, error: 'invalid_phone', message: 'El tel√©fono debe tener al menos 9 d√≠gitos.' };
      }

      const centerInfo = CENTERS[center.toLowerCase()];
      if (!centerInfo) {
        return { success: false, error: 'invalid_center', message: `Centro no v√°lido: ${center}` };
      }

      const typeId = APPOINTMENT_TYPES[centerInfo.agendaId]?.[treatment.toLowerCase()];
      if (!typeId) {
        return { success: false, error: 'invalid_treatment', message: `Tratamiento no v√°lido: ${treatment}` };
      }

      try {
        // Check if Smart Agenda credentials are configured
        if (!process.env.SMART_AGENDA_LOGIN || !process.env.SMART_AGENDA_PWD) {
          console.error('[ADMIN-TEST-CHAT] Smart Agenda credentials not configured!');
          return { success: false, error: 'config_error', message: 'Smart Agenda no est√° configurado. Contacta al administrador.' };
        }

        // Get or create client
        console.log('[ADMIN-TEST-CHAT] Fetching clients...');
        const clientsResponse = await smartAgendaRequest('/pdo_client');
        if (!clientsResponse.ok) {
          const errorText = await clientsResponse.text();
          console.error('[ADMIN-TEST-CHAT] Failed to get clients:', clientsResponse.status, errorText);
          throw new Error(`Failed to get clients: ${clientsResponse.status}`);
        }
        const clients = await clientsResponse.json();
        let client = clients.find(c => c.mail === email);

        // Parse name (needed for both new client and appointment)
        const nameParts = full_name.trim().split(' ');
        const lastName = nameParts[nameParts.length - 1];
        const firstName = nameParts.slice(0, -1).join(' ') || lastName;

        if (!client) {
          console.log('[ADMIN-TEST-CHAT] Creating new client:', { firstName, lastName, email, phone });
          const createResponse = await smartAgendaRequest('/pdo_client', {
            method: 'POST',
            body: JSON.stringify({ nom: lastName, prenom: firstName, mail: email, telephone: phone })
          });
          if (!createResponse.ok) {
            const errorText = await createResponse.text();
            console.error('[ADMIN-TEST-CHAT] Failed to create client:', createResponse.status, errorText);
            throw new Error(`Failed to create client: ${createResponse.status}`);
          }
          client = await createResponse.json();
          console.log('[ADMIN-TEST-CHAT] Client created:', client.id);
        } else {
          console.log('[ADMIN-TEST-CHAT] Existing client found:', client.id);
        }

        if (!client?.id) {
          throw new Error('Failed to create/get client - no ID returned');
        }

        // Get resource
        const resourcesResponse = await smartAgendaRequest('/pdo_ressource');
        const resources = await resourcesResponse.json();
        const resourceId = resources.find(r => r.id === '-1')?.id || resources[0]?.id || '-1';
        console.log('[ADMIN-TEST-CHAT] Using resource ID:', resourceId);

        // VALIDATION: Check if slot is actually available before booking
        console.log('[ADMIN-TEST-CHAT] Validating slot availability before booking...');
        const availCheckResponse = await smartAgendaRequest('/service/getAvailabilities', {
          method: 'POST',
          body: JSON.stringify({
            pdo_type_rdv_id: typeId,
            pdo_agenda_id: centerInfo.agendaId,
            date_a_partir_de: date,
            date_fin: date
          })
        });

        if (availCheckResponse.ok) {
          const availCheckData = await availCheckResponse.json();
          const daySlots = Array.isArray(availCheckData) ? availCheckData.find(d => d.dj === date) : null;
          const isTimeAvailable = daySlots?.det?.some(s => s.idp === time);

          console.log(`[ADMIN-TEST-CHAT] Slot validation: date=${date}, time=${time}, available=${isTimeAvailable}`);
          console.log(`[ADMIN-TEST-CHAT] Available times for ${date}:`, daySlots?.det?.map(s => s.idp).join(', ') || 'none');

          if (!isTimeAvailable) {
            console.log('[ADMIN-TEST-CHAT] SLOT NOT AVAILABLE - blocking booking');
            return {
              success: false,
              error: 'slot_unavailable',
              message: `El horario ${time} del ${date} ya no est√° disponible. Por favor consulta la disponibilidad nuevamente.`
            };
          }
        } else {
          console.log('[ADMIN-TEST-CHAT] WARNING: Could not validate slot availability, proceeding anyway');
        }

        // Create appointment
        const duration = TREATMENTS[treatment.toLowerCase()]?.duration || 60;
        const startDateTime = `${date}T${time}:00`;
        const endDate = new Date(startDateTime);
        endDate.setMinutes(endDate.getMinutes() + duration);

        const appointmentPayload = {
          client_id: client.id,
          client_nom: lastName,  // Required by API (matches working laserostop_bf)
          presta_id: typeId,
          ressource_id: resourceId,
          start_date: startDateTime,
          end_date: endDate.toISOString().slice(0, 19),
          equipe_id: centerInfo.agendaId,
          statut: 'C'  // Status: C = Confirmed (appears directly in agenda)
        };
        console.log('[ADMIN-TEST-CHAT] Creating appointment:', JSON.stringify(appointmentPayload));

        const appointmentResponse = await smartAgendaRequest('/pdo_events', {
          method: 'POST',
          body: JSON.stringify(appointmentPayload)
        });

        if (!appointmentResponse.ok) {
          const errorText = await appointmentResponse.text();
          console.error('[ADMIN-TEST-CHAT] Failed to create appointment:', appointmentResponse.status, errorText);
          throw new Error(`Failed to create appointment: ${appointmentResponse.status} - ${errorText}`);
        }

        const appointment = await appointmentResponse.json();
        console.log('[ADMIN-TEST-CHAT] Appointment response:', JSON.stringify(appointment));

        if (!appointment?.id) {
          console.error('[ADMIN-TEST-CHAT] No appointment ID in response:', JSON.stringify(appointment));
          throw new Error('No appointment ID returned');
        }

        console.log('[ADMIN-TEST-CHAT] Booking created with ID:', appointment.id);

        // CRITICAL: Verify the booking was actually created by fetching it back
        console.log('[ADMIN-TEST-CHAT] Verifying booking exists...');
        const verifyResponse = await smartAgendaRequest(`/pdo_events/${appointment.id}`);
        if (!verifyResponse.ok) {
          console.error(`[ADMIN-TEST-CHAT] CRITICAL: Booking verification FAILED! ID ${appointment.id} not found (status: ${verifyResponse.status})`);
          throw new Error(`Booking created but verification failed - ID ${appointment.id} does not exist`);
        }
        const verifiedBooking = await verifyResponse.json();
        console.log('[ADMIN-TEST-CHAT] Booking VERIFIED:', JSON.stringify(verifiedBooking));
        console.log(`[ADMIN-TEST-CHAT] BOOKING SUCCESS! Verified ID: ${verifiedBooking.id}, Client: ${verifiedBooking.client_id}, Date: ${verifiedBooking.start_date}`);

        // Log booking stats
        try {
          const { getRedisClient } = require('./shared/redis-client');
          const redisClient = await getRedisClient();
          if (redisClient) {
            const today = new Date().toISOString().split('T')[0];
            await redisClient.incr('chatbot:stats:bookings:total');
            await redisClient.incr(`chatbot:stats:bookings:${today}`);
            await redisClient.incr(`chatbot:stats:bookings:center:${center}`);
            await redisClient.incr(`chatbot:stats:bookings:treatment:${treatment}`);
            await redisClient.quit();
          }
        } catch (e) {
          console.error('[ADMIN-TEST-CHAT] Failed to log booking stats:', e.message);
        }

        return {
          success: true,
          appointmentId: appointment.id,
          center: centerInfo.name,
          treatment: TREATMENTS[treatment.toLowerCase()]?.name || treatment,
          price: TREATMENTS[treatment.toLowerCase()]?.price || 0,
          date,
          time,
          displayDate: formatSpanishDate(date),
          customerName: full_name,
          message: `Reserva confirmada en ${centerInfo.name} para el ${formatSpanishDate(date)} a las ${time}.`
        };

      } catch (error) {
        console.error('[ADMIN-TEST-CHAT] Booking error:', error.message);
        return { success: false, error: 'booking_failed', message: 'No se pudo crear la reserva. WhatsApp: +34 689 560 130' };
      }
    }

    case 'get_center_info': {
      if (args.center === 'all') {
        return {
          success: true,
          centers: Object.entries(CENTERS).map(([key, info]) => ({
            key,
            name: info.name,
            ...CENTER_DETAILS[key]
          }))
        };
      }

      const details = CENTER_DETAILS[args.center?.toLowerCase()];
      if (!details) {
        return { success: false, error: 'invalid_center', message: `Centro no encontrado: ${args.center}` };
      }

      return { success: true, ...details };
    }

    default:
      return { success: false, error: 'unknown_tool', message: `Herramienta desconocida: ${toolName}` };
  }
}

exports.handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  const authHeader = event.headers.authorization || '';
  const token = authHeader.replace('Bearer ', '');

  if (!token) {
    return { statusCode: 401, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Authorization required' }) };
  }

  const isValid = await validateAdminSession(token);
  if (!isValid) {
    return { statusCode: 401, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Invalid or expired session' }) };
  }

  try {
    const body = JSON.parse(event.body || '{}');
    const { message, conversationHistory = [] } = body;

    if (!message || typeof message !== 'string') {
      return { statusCode: 400, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Message is required' }) };
    }

    const openaiKey = process.env.OPENAI_API_KEY;
    if (!openaiKey) {
      return { statusCode: 500, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'OpenAI API key not configured' }) };
    }

    const startTime = Date.now();

    // Build messages array
    const messages = [
      { role: 'system', content: SYSTEM_PROMPT },
      ...conversationHistory.slice(-8),
      { role: 'user', content: message }
    ];

    // Detect if user is confirming a booking (simple pattern match)
    const isConfirmation = message.toLowerCase().match(/^(si|s√≠|ok|confirmo|adelante|yes|vale|claro|por supuesto|de acuerdo|perfecto|genial)/);

    // Check if conversation history suggests we're in a booking flow
    // Look for: confirmation questions, email/phone patterns, booking summaries
    const historyHasBookingData = conversationHistory.some(m => {
      if (!m.content) return false;
      const content = m.content.toLowerCase();
      return (
        content.includes('¬øconfirmo') ||
        content.includes('confirmo la reserva') ||
        content.includes('resumen') ||
        content.includes('@') ||  // Email was mentioned
        /\d{9}/.test(m.content) ||  // Phone number pattern
        content.includes('nombre completo') ||
        content.includes('correo') ||
        content.includes('tel√©fono')
      );
    });

    // Force create_booking tool if user is confirming after booking data was collected
    let toolChoice = 'auto';
    if (isConfirmation && historyHasBookingData) {
      console.log('[ADMIN-TEST-CHAT] Detected confirmation after booking data - forcing create_booking tool');
      toolChoice = { type: 'function', function: { name: 'create_booking' } };
    }

    // Call OpenAI with tools
    let response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${openaiKey}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages,
        max_tokens: 300,
        temperature: 0.7,
        tools: CHATBOT_TOOLS,
        tool_choice: toolChoice
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('[ADMIN-TEST-CHAT] OpenAI error:', errorData);
      return { statusCode: 500, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Failed to generate response' }) };
    }

    let data = await response.json();
    let totalTokens = data.usage?.total_tokens || 0;
    let responseMessage = data.choices?.[0]?.message;

    console.log(`[ADMIN-TEST-CHAT] User message: "${message.substring(0, 50)}..."`);
    console.log(`[ADMIN-TEST-CHAT] GPT finish_reason: ${data.choices?.[0]?.finish_reason}`);

    // Track if create_booking was called
    let createBookingCalled = false;
    let bookingResult = null;

    // Handle tool calls
    if (responseMessage?.tool_calls && responseMessage.tool_calls.length > 0) {
      console.log(`[ADMIN-TEST-CHAT] Tool calls: ${responseMessage.tool_calls.length}`);
      responseMessage.tool_calls.forEach(tc => {
        console.log(`[ADMIN-TEST-CHAT] - Tool: ${tc.function.name}, Args: ${tc.function.arguments.substring(0, 100)}...`);
      });

      const toolResults = [];
      for (const toolCall of responseMessage.tool_calls) {
        let args;
        try {
          args = JSON.parse(toolCall.function.arguments);
        } catch (e) {
          args = {};
        }

        const result = await executeToolCall(toolCall.function.name, args);

        // Track create_booking results
        if (toolCall.function.name === 'create_booking') {
          createBookingCalled = true;
          bookingResult = result;
          console.log(`[ADMIN-TEST-CHAT] create_booking called - success: ${result.success}, appointmentId: ${result.appointmentId || 'none'}`);
        }

        // CRITICAL: Add explicit instruction if no availability found
        if (toolCall.function.name === 'check_availability' && result.success && (!result.slots || result.slots.length === 0)) {
          console.log('[ADMIN-TEST-CHAT] Empty availability - adding explicit instruction to GPT');
          result.instruction = 'IMPORTANTE: No hay horarios disponibles. DEBES informar al usuario que no hay disponibilidad en este centro actualmente y ofrecer consultar otro centro o contactar por WhatsApp: +34 689 560 130. NO inventes horarios.';
        }

        toolResults.push({
          tool_call_id: toolCall.id,
          role: 'tool',
          content: JSON.stringify(result)
        });
      }

      // Send tool results back to GPT
      const finalMessages = [...messages, responseMessage, ...toolResults];

      response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${openaiKey}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: finalMessages,
          max_tokens: 300,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        return { statusCode: 500, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Failed to generate final response' }) };
      }

      data = await response.json();
      totalTokens += data.usage?.total_tokens || 0;
      responseMessage = data.choices?.[0]?.message;
    } else {
      // No tool calls - detect and fix fake confirmations
      const content = responseMessage?.content || '';
      const looksLikeConfirmation = content.toLowerCase().includes('confirmad') ||
                                     content.toLowerCase().includes('reserva creada') ||
                                     content.toLowerCase().includes('reserva lista') ||
                                     content.toLowerCase().includes('cita confirmada') ||
                                     content.includes('üéâ');
      const userSaidYes = message.toLowerCase().match(/^(si|s√≠|ok|confirmo|adelante|yes|vale|claro)/);

      if (looksLikeConfirmation && userSaidYes && !createBookingCalled) {
        console.log(`[ADMIN-TEST-CHAT] CRITICAL: Fake confirmation detected! Fixing response...`);
        console.log(`[ADMIN-TEST-CHAT] Original response: "${content.substring(0, 100)}..."`);
        // Override the fake confirmation with a proper message
        responseMessage.content = 'Hubo un problema al procesar la reserva. Por favor, proporciona de nuevo tus datos (nombre, email y tel√©fono) para que pueda completar la reserva correctamente.';
      }
    }

    const responseTime = Date.now() - startTime;
    let botResponse = responseMessage?.content || 'No response generated';

    // Strip markdown from response
    botResponse = stripMarkdown(botResponse);

    console.log(`[ADMIN-TEST-CHAT] Final response (${totalTokens} tokens, ${responseTime}ms)`);

    // Log if booking was confirmed
    if (createBookingCalled && bookingResult?.success) {
      console.log(`[ADMIN-TEST-CHAT] BOOKING CONFIRMED - ID: ${bookingResult.appointmentId}`);
    }

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        response: botResponse,
        tokens: totalTokens,
        responseTime,
        bookingCreated: createBookingCalled && bookingResult?.success,
        appointmentId: bookingResult?.appointmentId || null
      })
    };

  } catch (error) {
    console.error('[ADMIN-TEST-CHAT] Error:', error.message);
    return { statusCode: 500, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ error: 'Server error' }) };
  }
};
